# 264. Ugly Number 2
263 的 follow-up，找出第 n 个丑数，直接暴力解试过了会 TLE

天翼云笔试碰到了这题

有 2 种思想：DP 和 Heap

最本质的思路就是，丑数一定是已经获得的丑数乘以 2、3、5 来获得的

这种通过子问题来构建后面的更大的问题的想法，很容易让人想到 Top-down 的 DP

## DP 
乘 2: 1×2, 2×2, 3×2, 4×2, 5×2, 6×2, 8×2, 9×2,…

乘 3: 1×3, 2×3, 3×3, 4×3, 5×3, 6×3, 8×3, 9×3,…

乘 5: 1×5, 2×5, 3×5, 4×5, 5×5, 6×5, 8×5, 9×5,…

如何不错过乘 2、3、5 前面的每一个基数？

为 2、3、5 分别维护一个指针，初始化为 0

这样一来，每一次用到 2、3、5 的时候，就可以将相应的指针后移，自然而然遍历了丑数数组原有的每一个丑数

我们从数组中只包含一个丑数数字 1 开始，使用 3 个指针 i2, i3 和 i5，标记所指向丑数要乘以的因子。

算法：
- 在 2 x nums[i2]，3 x nums[i3] 和 5 x nums[i5] 选出最小的丑数并添加到数组中。
- 并将该丑数对应的因子指针往前走一步。重复该步骤直到计算完 1690 个丑数。

DP 的构思真的是太巧妙了，第一次做的话真的很难想到

## PrioirtyQueue && TreeSet
因为这 2 个数据结构都已经帮我们维护好大小顺序了，依次 poll 出第 1~n-1 个丑数，最后直接 poll 顶端元素即可

其实这题 TreeSet 才是代码最简单的

## 暴力解
每次都只能想到暴力解，但是会 TLE