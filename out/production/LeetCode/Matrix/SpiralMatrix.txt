Matrix 题

如何模拟这个过程，像瑞士卷一样一圈一圈往里

想到用圈数来遍历
比如：

[1,  2,  3],
[4,  5,  6],
[7,  8,  9]

一共有两圈 
外圈：1, 2, 3, 6, 9, 8, 7, 4
内圈：5

每一圈的起点都是：(0, 0), (1, 1), (2, 2) -> (n, n)

还是没想出来。。。 看官方答案吧

我的第一思路是官方 layer by layer 的解法

殊不知模拟方向数组是能用到的。。。
我起初想到了初始化方向数组，但是却想不到如何改变方向，因为脑子想的都是 BFS 那些题用到的方向数组，因为它们为自动遍历四个方向
然后就会想到 int[][] dirs = new int[][] {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
但其实这样的初始化是随机走才适用，我们这里是需要 simulation
应该是：
int[] dr = {0, 1, 0, -1};
int[] dc = {1, 0, -1, 0};
然后有一个切换方向的变量 int di = 0 -> di = (di + 1) % 4 -> dr[di] dc[di]

而这题方向先初始化为{0, 1} -> {1, 0} -> {0, -1} -> {-1, 0} 然后如此反复

还有就是没有想到需要一个 boolean 数组来标记是否遍历过
然后激发 di 改变值从而改变方向的条件是判断是否越界以及是否遍历过，没有的话就按原方向更新坐标
如果满足一项，就要更新 di -> (di + 1) % 4 以此来改变方向

还有要注意的是整个 for 循环遍历应该是 for (int i = 0; i < R * C; i++)

Layer by Layer 的方法
第一圈分 4 组
左上 -> 右上 1, 2, 3
右上 -> 右下 6, 9
右下 -> 左下 8, 7
左下 -> 左上 4

关键在于如何进入里面一层？
其实仔细一想，我们会发现，往里面一层，变的是四周的边界
也就是说我们得先把四周边界参数初始化：
int r1 = 0;                     // 上边界
int r2 = matrix.length - 1;     // 下边界
int c1 = 0;                     // 左边界
int c2 = matrix[0].length - 1;  // 右边界

进入里面一层：
r1++;
r2--;
c1++;
c2--;

还要注意需要判断边界条件，即只有一行和只有一列的情况
