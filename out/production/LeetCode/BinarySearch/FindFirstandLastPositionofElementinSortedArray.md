# 34. Find First and Last Position of Element in Sorted Array
在排好序的数组中找 target，输出第一次和最后一次出现的 index

二分法通常用来寻找 1 个 target，而这题就是典型的寻找 1 个 range，也就是左右边界

求左右边界的二分法通常的模板是：
1. 左闭右开
2. right = nums.length
3. while (left < right)

而左闭右开的区间决定了每次二分，都会分成 [left, mid) 和 [mid + 1, right) 这样 2 个区间

并且 left 的返回值的取值范围为 [0, nums.length]，所以我们在计算左边界时需要进行额外检查
- 左边界 -> nums[nums.length] 显然是越界的，所以这种情况直接返回 -1

右边界 -> 而对于右边界来说，返回的 left - 1，所以不需要额外检查

## Binary Search 
总体算法工作过程与线性扫描方法类似，除了找最左和最右下标的方法。

这里我们仅仅做几个微小的调整，用这种修改过的二分查找方法区搜索这个拍过序的数组。

首先，为了找到最左边（或者最右边）包含 target 的下标（而不是找到的话就返回 true），所以算法在我们找到一个 target 后不能马上停止。

我们需要继续搜索，直到 lo == hi 且它们在某个 target 值处下标相同。

另一个改变时 left 参数的引入，它是一个 boolean 类型的变量，指示我们在遇到 target == nums[mid] 时应该做什么。

如果 left 为 true，那么我们递归查询左区间，否则递归右区间。

考虑如果我们在下标为 i 处遇到了 target，最左边的 target 一定不会出现在下标大于 i 的位置，所以我们永远不需要考虑右子区间。

当求最右下标时，道理同样适用。

进行 2 次二分搜索分别找出起始 index 和终止 index

## Brute Force 
首先，我们对 nums 数组从左到右做线性遍历，当遇到 target 时中止。

如果我们没有中止过，那么 target 不存在，我们可以返回“错误代码” [-1, -1] 。

如果我们找到了有效的左端点坐标，我们可以坐第二遍线性扫描，但这次从右往左进行。

这一次，第一个遇到的 target 将是最右边的一个（因为最左边的一个存在，所以一定会有一个最右边的 target）。

