实现 x^n

注意到：Input: 2.00000, 10
       Output: 1024.00000
     
输出类型已经限定为 double

n 要分 正数 和 负数 讨论
if 正数：
  正常乘
if 负数：
  先将 x 倒置，再正常乘
  
  
这题边界条件是难点：
1. n == 0 -> return 1.00000;
2. x == 1 -> return 1.00000;

corner case: x = 2.00000, n = -2147483648  -> TLE 

但是原始代码还有一个问题，就是太慢了：
else if (n > 0) {
  double pow = x;
  while (n > 1) {
      x *= pow;
      n--;
  }
} else {
    double pow = 1 / x;
    while (n < 1) {
        x *= pow;
        n++;
    }
}
return x;

可以使用递归，将问题转化为二叉树，层数直接从 n 减为 logn
比如：2^2 = (2^1) * (2^1) = (2^0 * 2^0 * 2)


2^4 -> 4^2 -> 16
处理负数只用: 2^-2 = 1/2^2 相当于分母还是按正数来算

Integer.MIN_VALUE = -2147483648
Integer.MAX_VALUE = 2147483647


这里我们来探讨一下 int 类型的范围：
4 个字节，32 位
表示正数的时候，除了第 1 位是 0 固定不变，其它位可以取 0 也可以取 1，2^31，再减去 0，最大就是 2^31 - 1
表示负数的时候，除了第 1 位是 1 固定不变，其它位可以去 0 也可以取 1，2^31，负数比正数多 1 个

如果我们对 -2147483648 取相反数 -> 按位取反，末位加 1 
1000 0000 0000 0000 0000 0000 0000 0000 按位取反
0111 1111 1111 1111 1111 1111 1111 1111 + 1
1000 0000 0000 0000 0000 0000 0000 0000 等于又回来了  所以 Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE

可以用 Math.abs((long) Integer.MIN_VALUE) 来解决
