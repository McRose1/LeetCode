把 sorted 数组转换成 BST

想着用双指针和迭代做，用 mid 当 root，分别遍历 left 和 right，整体思路是对的

看答案

每次都找 mid 作为当前子树的 root
并且每次递归都返回当前 root
这样到最后就能从底部往上一层一层返回构建好的 BST

不要忘记加上递归的出口：if (left > right) return null;
[-10, -3, 0, 5, 9]    
          0
        /   \ 
  [-10, -3] [5, 9]
      /
    -10
      \    
       -3
left=0
right=1
mid=0
cur = -10
cur.left = helper(0, -1) -> (left > right) -> null
cur.right = helper(1, 1) -> (mid = 1) -> cur = -3

LC 官方：
众所周知，二叉搜索树的中序遍历是一个升序序列。

将有序数组作为输入，可以把该问题看做 根据中序遍历序列创建二叉搜索树。

BST 的特点：
中序遍历不能唯一确定一棵二叉搜索树。
先序和后序遍历不能唯一确定一棵二叉搜索树。
中序+后序、中序+先序可以唯一确定一棵二叉树。