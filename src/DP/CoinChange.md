# 322. Coin Change
非常经典的 DP 题，找零钱问题，给定一个数额，用手头的各种零钱去换，求使用的最少的钱的个数

[1, 2, 5] -> 11

第一反应是从 11 往回推

11 - 5 = 6 

6 - 5 = 1

1 - 1 = 0

其实也就是说 
- dp[11] = dp[6] + 1 -> 3
- dp[6] = dp[1] + 1 -> 2
- dp[1] = 1

## DP (Bottom-up) 
![Bottom-up](/src/images/%23322(2).png)

dp[i] = min(dp[i - cj] + 1)  
- j = 0...n-1

自底向上写起来要比自顶向下舒服很多，运行速度也更快

**优先选择自底向上**

## DP (Top-down) Recursion with Memoization 
![Top-down](/src/images/%23322(1).png)

在上面的递归树中，我们可以看到许多子问题被多次计算。例如，F(1) 被计算了 13 次。

为了避免重复的计算，我们将每个子问题的答案存在一个数组中进行记忆化，如果下次还要计算这个问题的值直接从数组中取出返回即可，这样能保证每个子问题最多只被计算一次。

原来一开始脑子想出来的是 Top-down 这种方法，但是感觉这种方法写起来比较难受

状态转移方程：

dp(s) = min(dp(S - ci) + 1) 

Constraints:
- S - ci >= 0
- i = 0...n-1

Base case:
- dp[0] = 0
