# 312. Burst Balloons
[3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
             
  3x1x5   +    3x5x8    +  1x3x8   +   1x8x1  =  167

这个问题 tricky 就 tricky 在于如果我们顺着题目的思维去想，也就是模拟戳气球的这整个过程，是非常难的。

需要我们转换问题：戳气球 -> 放气球

[] --> [8]   -->   [3,8]  --> [3,5,8] -->  [3,1,5,8]  
             
 0  +  1x8x1   +   1x3x8  +    3x5x8   +     3x1x5  =  167
  
为了方便处理，我们对 nums 数组稍作处理，将其两边各加上题目中假设存在的 num[-1] 和 nums[n]，并保存在新的数组 arr 中，即 arr[i] = nums[i - 1]。之所以这样处理是为了处理 nums[-1]，防止下标越界。

## 记忆化搜索
**我们观察戳气球的操作，发现这会导致 2 个气球从不相邻变成相邻，使得后续操作难以处理。于是我们倒过来看这些操作，将全过程看作是每次添加 1 个气球。**

定义方法 helper，令 helper(i, j) 表示将开区间 (i, j) 内的位置全部填满气球能够得到的最多硬币数。由于是开区间，因此区间两端的气球的编号就是 i 和 j，对应着 arr[i] 和 arr[j]。

- 当 i >= j - 1 时，开区间中没有气球，helper(i,j) 的值为 0；
- 当 i < j - 1 时，我们枚举开区间 (i,j) 内的全部位置 mid，令 mid 为当前区间第一个添加的气球，该操作能得到的硬币数为 arr[i] x arr[mid] x arr[j]。同时我们递归地计算分割出的 2 个区间对 helper(i,j) 的贡献，这三项之和的最大值，即为 hepler(i,j) 的值
  - 这样问题就转化为求 helper(i, mid) 和 helper(mid, j)

为了防止重复计算，我们存储 helper 的结果，使用记忆化搜索的方法优化时间复杂度。

利用分治的思想，每次在中间添加气球，比如 [1, 3, 1, 5, 8, 1]，在 [1, 1] 之间从 [3, 1, 5, 8] 选择 1 个数加入使得乘积最大

其实每个数都会试一次，最后结果显示先加 8 会使得最后最大，即 [1, 8, 1]，添加了 8 之后分成了左右 2 个区间，右侧区间已经满足 left + 1 = right，故接下来将在左侧区间内添加

## DP
我们发现可以通过变换计算顺序，从「自顶向下」的记忆化搜索变为「自底向上」的动态规划。

令 dp[i][j] 代表填满开区间 (i, j) 能得到的最大金币数，边界条件是 i >= j - 1，dp[i][j] = 0

dp[i][j] = arr[i] x arr[k] x arr[j] + dp[i][k] + dp[k][j]

**实现时要注意到动态规划的次序**

**注意 DP 数组首尾都需要加一个 1**