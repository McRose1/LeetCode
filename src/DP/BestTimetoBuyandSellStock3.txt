# 123. Best Time to Buy and Sell Stock 3

前两道 easy 题，第三题就是hard 了
区别在于这次规定最多交易两次

[3,3,5,0,0,3,1,4]
6

tag 里是 DP

## 篮子王
根据第一题只买卖一次的 DP 做法想到，如果我们能把这整个数组分成 2 个子序列，分别求前后序列最大收益相加

这样一来，会有 n 种分法 -> Time = O(n^2)，时间复杂度过大，想到用空间换时间

    [3,3,5,0,0,3,1,4]
p1: [0,0,2,2,2,3,3,4]（起点固定，从左到右）
p2: [4,4,4,4,4,3,3,0]（终点固定，从右到左）

看了这么多方法，还是篮子王这个方法最简洁明了

## 看一下windlang的方法

他引人的是交易次数，也就是 0 次交易，1 次交易，和题目限制的 2 次交易
用dp[i][k]表示前i天交易k次的最高收益

如果第i天什么都不做，那么 dp[i][k] = dp[i - 1][k]

如果我们在第i天选择卖出，那么 0 - i-1天必然需要选择一天买入，说明在买入之前已经进行了 k-1 次交易
在第 0 天买入，收益就会 prices[i] - prices[0]
在第 1 天买入，收益就会 prices[i] - prices[1] + dp[0][k - 1]，多加了前一天的最大收益
在第 2 天买入，收益就会 prices[i] - prices[2] + dp[1][k - 1]
...
在第 j 天买入，收益就会 prices[i] - prices[j] + dp[j - 1][k - 1]
上边的每一种可能选择一个最大的，然后与第i天什么都不操作比较，更大的就是dp[i][k]的值

为了让最后的代码更加简洁，我们可以换一下状态转移方程
因为我们选择在第 j 天买入，那么当前天的最大收益应该是等于前一天的最大收益的
所以改为 prices[i] - prices[j] + dp[j][k - 1]

dp[i][k] = Max(dp[i - 1][k], sum(prices[i] - prices[0 -> i] + dp[0 -> i][k - 1]))
         = Max(dp[i - 1][k], prices[i] - prices[j] + dp[j][k - 1]) (j取0 -> i)
而 prices[i] - prices[j] + dp[j][k - 1] 也可以看做 prices[i] - (prices[j] - dp[j][k - 1])，为了求最大值，相当于就是
求 prices[j] - dp[j][k - 1] 的最小值
而我们在遍历的时候其实这个最小值也是一层一层累加的，我们需要把之前的结果保存起来
初始条件 dp[i][0] = 0; dp[0][k] = 0

如果我们固定 k， 一列一列更新 dp，会发现：更新当前列只需要前一列的信息，即dp[0 -> i][k - 1]，所我们其实不需要二维数组，只需要一个一维数组

[3,3,5,0,0,3,1,4]
int[] min = [0, 3, 3]
int[] dp =  [0, 0, 0]

由于 K 是一个常数，所以我们的 min 数组和 dp 数组都可以分别当成两个变量
// first transaction 
min1 = Math.min(prices[i] - 0, min1);
dp1 = Math.max(dp1, prices[i] - min1);
// second transaction 
min2 = Math.min(prices[i] - dp1, min2);
dp2 = Math.max(dp2, prices[i] - min2);

     0 1 2 次交易
  ij 0 1 2   
3 0  0 0 0    
3 1  0 0    
5 2  0 2    
0 3  0
0 4  0
3 5  0
1 6  0
4 7  0

## 安卓大宝贝：
分为 5 个 phase
Phase1          Phase2              Phase3                Phase4              Phase5
第一次买入       手头有股票      第一次已经卖出且第二次还没买入  手头有股票            第二次卖出

dp[i][j]：在第i-1天结束后，在阶段j的最大获益

Phase1,3,5:
1. 前一天手头有股票，今天卖出：dp[i - 1][j - 1] + p(i - 1) + p(i - 2)
2. 前一天手头没有股票：       dp[i - 1][j]

Phase2,4
1. 前一天手头有股票，继续持有：dp[i - 1][j - 1] + p(i - 1) + p(i - 2)
2. 前一天手头没有股票：       dp[i - 1][j]

发现五个状态实在是太难想了，果断放弃大宝贝这个方法