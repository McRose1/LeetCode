# 1130. Minimum Cost Tree From Leaf Values
给定一个数组，里面的元素作为叶子节点，非叶子节点的 val 是它左右子树最大的叶子节点的乘积，求这样组成的二叉树非叶子节点之和的最小值

## 区间DP
凡是涉及到 tree 的 DP 问题，基本都是二维的区间 DP 问题

二维体现在给定树序列的子问题，也就是区间

一般这种题目都是 3 层循环，前 2 层代表区间的左右边界，最后一层为滑动的 k 来表示所选 root 将 tree 分为左右子树

像这题给定 [6, 2, 4]

实质上就是把这个数组分为 [6], [2], [4], [6, 2], [2, 4] 这样的子问题，最后 merge 成 [6, 2, 4]

[6], [2], [4] 单独的元素的结果应该都为 0，因为题目中要求 arr.length >= 2

而对于 [6, 2], [2, 4] 这种 2 个元素的结果就是 2 个数字的乘积

所以 base case 相当于就是 len = 1, 2，所有的大的问题最终都可以化解为这 2 种子问题

dp[i][j] = Math.min(dp[i][j], max[i][k] * max[k + 1][j] + dp[i][k] + dp[k + 1][j])   i <= k < j

[6, 2, 4] = min([6] + [2, 4], [6, 2] + [4]) = min(6 * 4 + 0 + 2 * 4, 6 * 4 + 6 * 2 + 0) = min(32, 36) = 32

## Stack 
大大优化了时间复杂度

观察 1：尽量保证大的值深度相对低，这样乘它的机会就少

相当于维护了一个单调递减栈，为了让大的数在树中深度相对低，反映在栈中就是让它在栈中的深度足够深

每当栈顶的元素小于数组遍历到的元素，为了维护单调栈，所以需要 pop 出栈顶元素，和下一个元素相乘加入结果

由于 pop 出的栈顶元素是当前区间内最小的元素，所以后续子树里最大叶子节点乘积里不会再用到它，所以可以直接 drop 掉。






