# 5. Longest Palindromic Substring
回文子串 DP 经典题，但是这题用 DP 是最慢的

## 中心扩散法
二维 DP 可以进一步优化空间复杂度，用中心扩散的思想
因为如果 s[i~j] 是回文字符串，那么 s[i+1~j-1] 一定也是回文字符串
所以我们从中心出发，每次判断左右两边的字符是否相等，相等即可继续往两边扩散
这一方法的精华在于如何选择中心，我们知道，奇数长度的字符串的中心就是中间唯一的那一个字符，而对于长度为偶数的字符串，其中心应该为两个字符的中间
所以我们在循环里每次先选定字符串里的任意 index，然后同时考虑奇数和偶数的情况，分别计算由这两个中心向两边扩散所能得到的最大回文字符串

## 山景城一姐：
二维 DP：Time = O(n^2) Space = O(n^2)
boolean[] dp = new boolean[sLen][sLen]
先初始化：
for (int i = 0; i < s.length(); i++) {
  for (int j = 0; j < s.length(); j++) {
    if (i == j) {
      dp[i][j] = true;
    }
  }
}

    end b a b a d
start
  b     T F T F F
  a       T F T F
  b         T F F
  a           T F
  d             T

当 start 和 end 相同时，判断 start 和 end 中间这段字符串是否为回文字符串
b  x x x x x x  b     dp[i][j] = s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]
i i+1       j-1 j
这个条件的前提是 start 和 end 中间至少夹了 1 个字符，也就是 j - i > 2，这样的前提下再去判断 dp[i + 1][j - 1] 才有意义
如果 j - i <= 2，那么只要 start 和 end 所表示的字符相同时，这整一个字符串就已经是回文字符串：a, aa, aba

这个题 DP 解法的核心在于 dp[i][j] 由 dp[i + 1][j - 1] 所决定，也就是说，dp[i + 1][j - 1] 一定得是先于 dp[i][j] 计算的，反映在二维 DP 上是每个格子取决于它左下角的格子

有两种扫法

1.
for (int j = 0; i < n; i++) {
    for (int i = 0; i <= j; i++) {
    }
}
    | | | |
      | | |
        | |
          |

2.
for (int i = n - 1; i >= 0; i--) {
    for (int j = n - 1; j >= i; j--) {
    }
}
    < - - - -
      < - - -
        < - -
          < -


## Manacher 算法
专门用于查找最长回文子串的算法：Time = O(n^2) -> O(n)

将原始字符串进行预处理，在预处理字符串上执行“动态规划”和“中心扩散”方法。
为了讲奇、偶数回文串的性质统一表示，将原始字符串进行预处理，用不在输入字符串中的字符隔开。

原始字符串                               A B A A B A
预处理字符串                        # A # B # A # A # B # A #
index                             0 1 2 3 4 5 6 7 8 9 10 11 12
以i为中心的最长回文子串的长度         1 3 1 7 1 3 13 3 1 7 1 3 1
对应原始字符串中的最长回文子串的长度   0 1 0 3 0 1 6 1 0 3 0 1 0

（预处理字符串的回文子串的长度 - 1）/ 2 = 原始字符串的回文子串的长度 = 以 i 为中心向两边能扩散的步数

