回文子串 DP 经典题

山景城一姐：
二维 DP：Time = O(n^2) Space = O(n^2)
boolean[] dp = new boolean[sLen][sLen]
先初始化：
for (int i = 0; i < s.length(); i++) {
  for (int j = 0; j < s.length(); j++) {
    if (i == j) {
      dp[i][j] = true;
    }
  }
}

    end b a b a d
start
  b     T F T F F
  a       T F T F
  b         T F F
  a           T F
  d             T

当 start 和 end 相同时，判断 start 和 end 中间这段字符串是否为回文字符串
b  x x x x x x  b     dp[i][j] = s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]
i i+1       j-1 j
这个条件的前提是 start 和 end 中间至少夹了 1 个字符，也就是 j - i > 2，这样的前提下再去判断 dp[i + 1][j - 1] 才有意义
如果 j - i <= 2，那么只要 start 和 end 所表示的字符相同时，这整一个字符串就已经是回文字符串：a, aa, aba

这个题 DP 解法的核心在于 dp[i][j] 由 dp[i + 1][j - 1] 所决定，也就是说，dp[i + 1][j - 1] 一定得是先于 dp[i][j] 计算的，反映在二维 DP 上是每个格子取决于它左下角的格子

有两种扫法

1.
for (int j = 0; i < n; i++) {
    for (int i = 0; i <= j; i++) {
    }
}
    | | | |
      | | |
        | |
          |

2.
for (int i = n - 1; i >= 0; i--) {
    for (int j = n - 1; j >= i; j--) {
    }
}
    < - - - -
      < - - -
        < - -
          < -


二维 DP 可以进一步优化空间复杂度


