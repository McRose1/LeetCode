看起来不像，其实这题是 84 题的 follow up

这道 hard 题好多 tag：
有 哈希表，DP，还有 stack

二维 DP 没想出来

从每一行往上看，把当前看作为直方图的底（x 轴） -> 看作一维的直方图

[
  ["1", "0", "1", "0", "0"],
  ["1", "0", "1", "1", "1"],
  ["1", "1", "1", "1", "1"],
  ["1", "0", "0", "1", "0"]
]

row 1: [1, 0, 1, 0, 0] 
row 2: [2, 0, 2, 1, 1]
row 3: [3, 1, 3, 2, 2]
row 4: [4, 0, 0, 3, 0]
变成这样的格式以后我们就可以用 84 题的 function 来解决了 -> stack

问题也就变成了如何把 char[][] 转换成我们所需要的这四个 int[]  -> DP
现在才意识到，这题其实是综合了 stack 和 DP

我们需要的这四个 int[] 其实组合起来就是一个二维的 dp 数组
dp[0][c] = matrix[0][c]
if (matrix[i][j] == 1) {
  dp[i][j] = dp[i - 1][j] + 1 
} else {
  dp[i][j] = matrix[i][j]
}

这题真的太有意思了，居然可以结合两个考点

其实也可以不用到二维 DP 数组

直接一维的数组，然后放在两个 for 循环里面，每一层都会更新一遍，节省了空间复杂度
