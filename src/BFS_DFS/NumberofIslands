亚麻有考这题

在这有 0 和 1 的矩阵中，连着的 1 算作 1 个岛屿

BFS/DFS 的题每次拿到都没啥思路

大概有 DFS 的思路：
首先需要找遍历的起点
这里我直接遍历整个矩阵，让每个元素都作为起点试一下
排除 visited 和 0 的情况

做不出来。。。
看答案吧

发现自己有点想反了
直接遇到 1 就开始 DFS 不就完事了（不影响结果）
整体思路是对的
不需要要 visited 数组，只要在遍历 1 之前把这个位置置为 0 就行，起到了 visited 的左右
并且需要边界检查

还可以用 BFS，肯定就需要 queue 的帮忙了
这里比较厉害的地方在于这个 queue 里存的是矩阵的 index，也就是 0 - m*n-1，而不是直接存坐标
每次算新坐标的时候就把这个 index 从 queue 里拿出来，通过 index / col 和 index % col 来得到新坐标
这一点太巧妙了

最后一种方法是 Union Find ，但是这题用并查集做其实是做复杂起来了
这两种方法在这题都比 DFS 慢很多








