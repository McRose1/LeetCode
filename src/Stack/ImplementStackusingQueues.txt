用 queue 来实现 stack 的功能
push、pop、top、empty

可以 assume 所有的操作都是 valid 的

queue 是先进先出，stack 是先进后出

| 4(new)
| 3 |        -------      --------                                   --------       --------       --------
| 2 |   4 ->  3 2 1 |     3 2 1 4 | -> queue.offer(queue.pop()) ->   2 1 4 3 |  ->  1 4 3 2 | ->   4 3 2 1 |
| 1 |        -------      --------                                   --------       --------       --------
|---|

用 1 个 queue 的思路其实最简单

每次 offer 的时候，先 offer 新值，因为 queue 里原有的值排序已经满足 stack 的先进后出，所以可以看做是一个整体，只要把原先的值重新 offer 进 queue，就能维护 stack 的特性


2 queue, push 复杂版：（个人感觉比 push 简单版要更简单）

                q1                  q2                        q2
| 2(new)|     -----               -----                      ------             
| 1 |           1 | -> push(2)      2 |  q2.add(q1.poll())    2 1 |    每次让 q1 和 q2 里的元素互换，让 q1 相当于是 stack
|---|         -----               -----                      ------        



2 queue, push 简单版：

| 4(new)                     q1                                     q2      q1
| 3 |        -------      -------                                -------   ----        
| 2 |   4 ->  1 2 3 |     1 2 3 4 | -> q2.offer(q1.pop()) ->     1 2 3 | 4(poll) |   记得还原，让 q1 和 q2 里的元素互换
| 1 |        -------      --------                               -------   ----      
|---|


