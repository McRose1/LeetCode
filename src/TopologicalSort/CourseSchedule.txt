少有的拓扑排序题，在有先修课程为限制条件下，判断是否能上完所有的课，也就是判断是否能遍历图中所有的节点
课程安排关系，必须先上先修课程才能继续上后面的课程，一层一层
拓扑排序最大的特点在于没有 cycle，如果有 cycle 就不存在必须先修什么课程了

tag 里还有 BFS/DFS

看答案吧
原来拓扑排序是可以用 BFS/DFS 实现的意思

拓扑排序的题 = 建立 graph + BFS/DFS

山景城一姐
对于有向图，
每个顶点有两个“度”
从该点出发的边数为“出度”
指向该点的边数为“入度”

这个题我们只关心入度

   0(0)  
     \ 
      4(2)  
     /   \
  1(0)     5(2) 
    \    /
     3(2)  
    /
  2(0)
  
先根据课表做一个 graph
在程序里面表示 graph 的常见两种方式：
1. 邻接矩阵（adjancency list）
2. 邻接表（adjancency graph）HashMap

这个题用邻接表
key 是当前 node
value 是从这个 node 能到达的 node

同时维护一个 inDegree 数组作为限制

有了图以后就能开始获取拓扑序列，相当于用 BFS/DFS

BFS 有两种思路：
一种是通过 queue 每次 offer 进去入度为 0 的课
每次 poll 出来的时候就将 count++，最后判断 count 是否等于课程数

也可以用入度数组来表示，最后都置为 0，说明都上过了

DFS 比较难想，需要判断 graph 是否存在 cycle
需要两种标记，一个是表明当前 DFS 已经访问过，可记为 visiting，还有一个是表明其他 DFS 已经访问过，记为 visited
如果在一轮 DFS 中我们遇到了 2 次 visiting 的 node，说明存在 cycle
如果遇到的是 visited，我们就已经知道通过这个 node 是不会有 cycle

这题非常好，以后要回来多看看！

BFS 思路大致掌握了，DFS 还没想透彻








  
  
  
