# 300. Longest Increasing Subsequence
从无序的数字序列中，找出最长的升序序列，返回最大值（注意，subsequence 是不连续的）

## DP
定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度。

状态转移方程：

dp[i] = max(dp[j]) + 1 (0 <= j < i 且 nums[j] < nums[i])

LIS = max(dp[i]), 0 <= i < n

相当于就是：

[10, 9, 2, 5, 3, 7, 101, 18]

&nbsp;&nbsp; j &nbsp;&nbsp;&nbsp; i 
 
 2 层循环，每取一次 i，遍历每一种 j 的可能性
 
![dp](/src/images/%23300.png)

感觉这题还是 DP 好写一些，二分法其实本质上不像 DP 了，更像是贪心对于 DP 的优化

**但是二分法的确要快一些**

## Greedy + Binary Search
考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。

基于上面的贪心思路，我们维护一个**单调递增**的数组 d[i]，表示长度为 i 的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度。

算法：
- 设当前已求出的最长上升子序列的长度为 len（初始为 1），从前往后遍历数组 nums，在遍历到 nums[i] 时：
  - 如果 nums[i] > d[len]，则直接加入到 d 数组末尾，并更新 len = len + 1;
  - 否则，在 d 数组中二分查找，找到第一个比 nums[i] 小的数 d[k]，并更新 d[k + 1] = nums[i]
  
[0, 8, 4, 12, 2]
- [0]
- [0, 8]
- [0, 4] 4 < 8
- [0, 4, 12]
- [0, 2, 12] 2 < 12

虽然最终 d 数组并不是我们要的 LIS 序列，但是长度是相同的
