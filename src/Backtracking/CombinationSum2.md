# 40. Combination Sum 2
和第一题唯一的区别在于现在数组里的元素只能使用**一次**

并且会发现给定的 candidates 数组是乱序的，并且例子里输出都是升序的，想到应该需要先把数组排个序来防止 duplicate

其实不用加 boolean[] 数组记录元素是否用过

关键代码！**if (i != start && candidates[i] == candidates[i - 1]) continue;**

[1, 1, 2, 5] 这种，如何避免出现 2 个 [1, 2, 5]

就是在出现 1 次 [1, 2, 5] 以后开始回溯的时候，从 index = 0 的这个 1 会遍历到 index = 1 的这个 1 的时候

多加 1 个判断，判断当前元素是否和前面一个元素相同，并且由于涉及到 i - 1，所以一定会有一个前提，也就是 i != start 或者 i > start 说明此时当前元素前面至少会有 1 个元素
